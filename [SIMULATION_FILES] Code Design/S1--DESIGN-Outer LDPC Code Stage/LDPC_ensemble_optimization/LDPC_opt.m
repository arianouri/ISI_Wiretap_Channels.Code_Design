function [Lambda] = LDPC_opt(Objective,Inequality,Equality,...
                                  tol,tol_feas,...
                                  Rho,AR,Lambda0,AL,maxLLR,number_of_bits,pE_E,Ell,teybel,...
                                  MAIN,WRTP,SupCha_CODEBOOK,R_s,R_in,C_E,TC_inp_length,TC_inp_msg,Window_size,...
                                  R0,p_rl,p_rs,subIter)
                              
% Rho = LDPC_opt_RHO('rho_objective',                                     ...
%                'rho_inequality_constraint',                             ...
%                'rho_equality_constraint',                               ...
%                 Rho,Lambda0,2);
            
Lambda = Lambda0;
beta = 0.9; % this parameter is used in the line search
Eps = 1e-2; % this parameter is used in the line search.
            % ...It is the sphere constraint. Can be higher
            % ...at the beginning and then get shorter.

[~,D_v] = size(Lambda);
% [~,D_c] = size(Rho);
R_out = rate_calculation(Lambda,Rho);
R_out = R_out/(1-p_rs);
% if R_out > R0
%     return;
% end

[MAIN_p_e_in,                                                           ...
 MAIN_p_e_out,                                                          ...
 MAIN_egzEt_cube]                                                       ...
          =DE_SUBCODE(Rho,AR,Lambda0,AL,                                ...
                      MAIN.sigma,                                       ...
                      MAIN.SupCha_Trans_EX,SupCha_CODEBOOK,             ...
                      maxLLR,number_of_bits,pE_E,Ell,teybel,            ...
                      TC_inp_length,TC_inp_msg,p_rl,               ...
                      MAIN.ChannelOutVec,Window_size,subIter);
                              
% [WRTP_p_e_in,                                                           ...
%  WRTP_p_e_out,                                                          ...
%  WRTP_egzEt_cube]                                                       ...
%      =DE_SUBCODE_FICT(Rho,AR,Lambda0,AL,                                ...
%                       WRTP.sigma,                                       ...
%                       WRTP.SupCha_Trans_EX,SupCha_CODEBOOK,             ...
%                       maxLLR,number_of_bits,pE_E,Ell,teybel,            ...
%                       TC_inp_length,TC_inp_msg,p_rs,                    ...
%                       WRTP.ChannelOutVec,Window_size);

MAIN_f_exit = reshape(MAIN_egzEt_cube(:,1,:),                           ...
                      size(MAIN_egzEt_cube,1),size(MAIN_egzEt_cube,3));
% WRTP_f_exit = reshape(WRTP_egzEt_cube(:,1,:),                           ...
%                       size(WRTP_egzEt_cube,1),size(WRTP_egzEt_cube,3));

% n = length(MAIN_p_e_in)+length(WRTP_p_e_in);
n=length(MAIN_p_e_in);

last_n = n;

[~,Objective_grad,~] = feval(Objective, Lambda);
[Equality_value] = feval(Equality,Lambda);
% [Inequality_value, Inequality_grad]  = feval(Inequality,Lambda,         ...
%                                              MAIN_f_exit,               ...
%                                              MAIN_p_e_out.',MAIN_p_e_in.',...
%                                              WRTP_f_exit,               ...
%                                              WRTP_p_e_out.',WRTP_p_e_in.');

    [Inequality_value, Inequality_grad]                                 ...
                                     = feval(Inequality,Lambda,         ...
                                             MAIN_f_exit,               ...
                                             MAIN_p_e_out.',MAIN_p_e_in.');

u = ones(D_v-1,1);  % this is the traspose of matrix A of the equality constraints, which is a vector here.
T = length(Inequality_value);
TT = length(Equality_value);
iter = 0;
y = ones(T,1);   %initializing the vectors 'y' and 'z'
z = ones(TT,1);
gamma = -y.'*Inequality_value;   % surrogate duality gap

%% reporting the parameters

while (gamma >= tol                                                     ...
      || norm(Objective_grad+(Inequality_grad.')*y+u*z)>=tol_feas        ...
      || norm(1-u.'*(Lambda(2:end)).') >= tol_feas)  % 3 stopping conditions are used    
    
    [~,Objective_grad,Objective_hess] = feval(Objective, Lambda);
    [Equality_value] = feval(Equality,Lambda);
%     [Inequality_value, Inequality_grad]                                 ...
%                                      = feval(Inequality,Lambda,         ...
%                                              MAIN_f_exit,               ...
%                                              MAIN_p_e_out.',MAIN_p_e_in.',...
%                                              WRTP_f_exit,               ...
%                                              WRTP_p_e_out.',WRTP_p_e_in.'); 

    [Inequality_value, Inequality_grad]                                 ...
                                     = feval(Inequality,Lambda,         ...
                                             MAIN_f_exit,               ...
                                             MAIN_p_e_out.',MAIN_p_e_in.');

%     R_out = rate_calculation(Lambda,Rho);   
%     
%     cm=-Objective_val/(1-R_out);
%     aCoef=ceil(cm)-cm;
%     bCoef=cm-floor(cm);
%     Rho=zeros(size(Rho));
%     Rho(floor(cm))=aCoef;
%     Rho(ceil(cm))=bCoef;
    
    T = length(Inequality_value);
    if last_n > n
        temp_y = zeros(T,1);
        temp_y(1:D_v+n-1) = y(1:D_v+n-1);
        temp_y(D_v+n:end) = y(D_v+last_n:D_v+last_n+n-1);       
    else
        temp_y = ones(T,1);
        temp_y(1:D_v+last_n-1) = y(1:D_v+last_n-1);
        temp_y(D_v+n:D_v+n+last_n-1) = y(D_v+last_n:end);
    end
    y = temp_y;
    last_n = n;
    miu = 10 * T / gamma;
    
    coeff_mat = [Objective_hess          Inequality_grad.'       u ;                         ...
                 diag(y)*Inequality_grad diag(Inequality_value) zeros(T,size(u,2));         ...
                 u.'                      zeros(size(u.',1),T)    zeros(size(u.',1),size(u,2))];
             
    const_mat = [-Objective_grad-(Inequality_grad.')*y-u*z;              ...
                 -diag(y)*Inequality_value-ones(T,1)/miu;               ...
                 1-u.'*(Lambda(2:end)).'];
             
    direction = (coeff_mat)^(-1) * const_mat; %calculating the direction using the Newton's method
    delta_Lambda = direction(1:D_v-1);
    delta_y = direction(D_v:D_v+T-1);
    delta_z = direction(D_v+T:end);
    s = Eps;                  %initializing the parameter for the line search   
    Lambda0 = Lambda.';
    Lambda0(2:end) = (Lambda(2:end)).' + s * delta_Lambda;    % Lambda is a row vector, but delta_Lambda is a column vector
    Lambda0 = (Lambda0).';
    
%     [Inequality_value, Inequality_grad]                                 ...
%                                      = feval(Inequality,Lambda,         ...
%                                              MAIN_f_exit,               ...
%                                              MAIN_p_e_out.',MAIN_p_e_in.',...
%                                              WRTP_f_exit,               ...
%                                              WRTP_p_e_out.',WRTP_p_e_in.');

    [Inequality_value, Inequality_grad]                                 ...
                                     = feval(Inequality,Lambda,         ...
                                             MAIN_f_exit,               ...
                                             MAIN_p_e_out.',MAIN_p_e_in.');
    
    y0 = y + s * delta_y;
    
    % doing line search to maintain feasibility and maintaining y>
    while( sum(Inequality_value(1:D_v-1)<=0) ~= D_v-1 || sum(y0>=0) ~= T)        
        s = s * beta ;     
        Lambda0 = Lambda.';
        Lambda0(2:end) = (Lambda(2:end)).' + s * delta_Lambda;
        Lambda0 = (Lambda0).';        
        y0 = y + s * delta_y;
%         [Inequality_value, Inequality_grad]                             ...
%                                      = feval(Inequality,Lambda,         ...
%                                              MAIN_f_exit,               ...
%                                              MAIN_p_e_out.',MAIN_p_e_in.',...
%                                              WRTP_f_exit,               ...
%                                              WRTP_p_e_out.',WRTP_p_e_in.');  

    [Inequality_value, Inequality_grad]                                 ...
                                     = feval(Inequality,Lambda,         ...
                                             MAIN_f_exit,               ...
                                             MAIN_p_e_out.',MAIN_p_e_in.');
    end
    
    Lambda = Lambda0;         %updating 'Lambda' and 'y' and 'z'
%     Rho = LDPC_opt_RHO('rho_objective',                                 ...
%                    'rho_inequality_constraint',                         ...
%                    'rho_equality_constraint',                           ...
%                     Rho,Lambda,2);

    y = y0;
    z = z + s * delta_z;
    iter = iter + 1;

    [MAIN_p_e_in,                                                           ...
     MAIN_p_e_out,                                                          ...
     MAIN_egzEt_cube]                                                       ...
              =DE_SUBCODE(Rho,AR,Lambda0,AL,                                ...
                          MAIN.sigma,                                       ...
                          MAIN.SupCha_Trans_EX,SupCha_CODEBOOK,             ...
                          maxLLR,number_of_bits,pE_E,Ell,teybel,            ...
                          TC_inp_length,TC_inp_msg,p_rl,                    ...
                          MAIN.ChannelOutVec,Window_size,subIter);

%     [WRTP_p_e_in,                                                           ...
%      WRTP_p_e_out,                                                          ...
%      WRTP_egzEt_cube]                                                       ...
%          =DE_SUBCODE_FICT(Rho,AR,Lambda0,AL,                                ...
%                           WRTP.sigma,                                       ...
%                           WRTP.SupCha_Trans_EX,SupCha_CODEBOOK,             ...
%                           maxLLR,number_of_bits,pE_E,Ell,teybel,            ...
%                           TC_inp_length,TC_inp_msg,p_rs,                    ...
%                           WRTP.ChannelOutVec,Window_size);

    MAIN_f_exit = reshape(MAIN_egzEt_cube(:,1,:),                           ...
                          size(MAIN_egzEt_cube,1),size(MAIN_egzEt_cube,3));
%     WRTP_f_exit = reshape(WRTP_egzEt_cube(:,1,:),                           ...
%                           size(WRTP_egzEt_cube,1),size(WRTP_egzEt_cube,3));
                      
    gamma = -y.'*Inequality_value;
    
%     n = length(MAIN_p_e_in)+length(WRTP_p_e_in);
    n=length(MAIN_p_e_in);
    
    
    [iter]
    R_out = rate_calculation(Lambda,Rho);
    R_out = R_out/(1-p_rs);
    
    disp(['Rate at this stage: ',num2str(R_out)]);
    disp(['Equivocation Rate: ',num2str(((R_out * R_in)-mean(C_E))/R_s)]);

    disp(['Surrogate duality gap: ',num2str(gamma)]);
    disp(['Equality constraint value: ',num2str(Equality_value)]);
    disp(['The maximum value of the inequality  values achieved: ',num2str(max(Inequality_value))]);
    disp(['Dual residual value: ',num2str(norm(Objective_grad+(Inequality_grad.')*y+u*z))]);
    disp(['BER: ', num2str(MAIN_p_e_in(end)) ]);
        save(num2str(iter));
end